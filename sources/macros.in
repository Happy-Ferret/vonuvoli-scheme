

#[ macro_export ]
macro_rules! succeeded {
	( $outcome : expr ) => (
		$crate::prelude::Result::Ok ($outcome)
	);
}

#[ macro_export ]
macro_rules! failed_or_panic {
	( $code : expr, $outcome : expr ) => (
		if true {
			$outcome
		} else {
			panic! ("{:08x}", $code as u32);
		}
	);
}

#[ macro_export ]
macro_rules! failed {
	( $code : expr ) => (
		failed_or_panic! ($code, $crate::prelude::Result::Err ($crate::errors::exports::error_generic ($code)))
	);
}

#[ macro_export ]
macro_rules! failed_unimplemented {
	( $code : expr ) => (
		failed_or_panic! ($code, $crate::prelude::Result::Err ($crate::errors::exports::error_unimplemented ($code)))
	);
}

#[ macro_export ]
macro_rules! failed_panic {
	( $code : expr ) => (
		failed_or_panic! ($code, $crate::prelude::Result::Err ($crate::errors::exports::error_panic ($code)))
	);
}


#[ macro_export ]
macro_rules! succeed {
	( $outcome : expr ) => (
		return succeeded! ($outcome);
	);
}

#[ macro_export ]
macro_rules! fail {
	( $code : expr ) => (
		return failed! ($code);
	);
}

#[ macro_export ]
macro_rules! fail_unimplemented {
	( $code : expr ) => (
		return failed_unimplemented! ($code); // OK
	);
}

#[ macro_export ]
macro_rules! fail_panic {
	( $code : expr ) => (
		return failed_panic! ($code);
	);
}

#[ macro_export ]
macro_rules! fail_unreachable {
	( $code : expr ) => (
		return failed_panic! ($code);
	);
}




#[ macro_export ]
macro_rules! succeed_or_fail {
	( $result : expr, $code : expr ) => (
		if let $crate::prelude::Result::Ok (value) = $result {
			succeed! (value);
		} else {
			fail! ($code);
		}
	);
}

#[ macro_export ]
macro_rules! try_or_fail {
	( $result : expr, $code : expr ) => (
		if let $crate::prelude::Result::Ok (value) = $result {
			value
		} else {
			fail! ($code);
		}
	);
}




#[ macro_export ]
macro_rules! enforce {
	( $expression : expr, $code : expr ) => (
		if !$expression {
			fail! ($code);
		}
	);
}




macro_rules! try_some {
	( $option : expr, $code : expr ) => (
		if let $crate::prelude::Option::Some (value) = $option {
			value
		} else {
			fail! ($code);
		}
	);
}

macro_rules! try_some_ref {
	( $option : expr, $code : expr ) => (
		if let $crate::prelude::Option::Some (ref value) = $option {
			value
		} else {
			fail! ($code);
		}
	);
}

macro_rules! try_some_2 {
	( $result : expr, $code : expr ) => (
		try_some! (try! ($result), $code)
	);
}

macro_rules! try_some_ref_2 {
	( $result : expr, $code : expr ) => (
		try_some_ref! (try! ($result), $code)
	);
}




macro_rules! impl_from_for_box {
	( $to : ty, $from : ty ) => (
		impl_from_for_box! ($to, $from, value, $to (value.into ()));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdFrom<$from> for $crate::prelude::StdBox<$to> {
			#[ inline (always) ]
			fn from ($value : $from) -> ($crate::prelude::StdBox<$to>) {
				return $crate::prelude::StdBox::new ($crate::prelude::StdFrom::<$to>::from ($expression));
			}
		}
		impl $crate::prelude::StdTryFrom<$from> for $crate::prelude::StdBox<$to> {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$crate::prelude::StdBox<$to>, $crate::errors::exports::Error>) {
				succeed! ($crate::prelude::StdFrom::from (value));
			}
		}
		impl $crate::prelude::StdTryInto<$crate::prelude::StdBox<$to>> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$crate::prelude::StdBox<$to>, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
	);
}


macro_rules! impl_try_from_for_box {
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdTryFrom<$from> for $crate::prelude::StdBox<$to> {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from ($value : $from) -> ($crate::prelude::Result<$crate::prelude::StdBox<$to>, $crate::errors::exports::Error>) {
				succeed! ($crate::prelude::StdBox::new ($crate::prelude::StdFrom::<$to>::from (try! ($expression))));
			}
		}
		impl $crate::prelude::StdFrom<$from> for $crate::prelude::StdBox<$to> {
			#[ inline (always) ]
			fn from (value : $from) -> ($crate::prelude::StdBox<$to>) {
				return $crate::prelude::StdTryFrom::try_from (value) .expect ("421e5427");
			}
		}
		impl $crate::prelude::StdTryInto<$crate::prelude::StdBox<$to>> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$crate::prelude::StdBox<$to>, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
	);
}




macro_rules! impl_from_for_type {
	( $to : ident, $from : ty ) => (
		impl_from_for_type! ($to, $from, value, $to (value.into ()));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from ($value : $from) -> ($to) {
				return $crate::prelude::StdFrom::<$to>::from ($expression);
			}
		}
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				succeed! ($crate::prelude::StdFrom::from (value));
			}
		}
		impl $crate::prelude::StdTryInto<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
		impl_from_for_box! ($to, $from, $value, $expression);
	);
}


macro_rules! impl_try_from_for_type {
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from ($value : $from) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				succeed! ($crate::prelude::StdFrom::<$to>::from (try! ($expression)));
			}
		}
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from (value : $from) -> ($to) {
				return $crate::prelude::StdTryFrom::try_from (value) .expect ("d747d1de");
			}
		}
		impl $crate::prelude::StdTryInto<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
		impl_try_from_for_box! ($to, $from, $value, $expression);
	);
}




macro_rules! impl_as_ref_for_type {
	( $from : ty ) => (
		impl_as_ref_for_type! ($from, $from, self, self);
	);
	( $to : ty, $from : ty, $self : ident, $expression : expr ) => (
		impl $crate::prelude::StdAsRef<$to> for $from {
			#[ inline (always) ]
			fn as_ref (&$self) -> (&$to) {
				return $expression;
			}
		}
		impl $crate::prelude::StdTryAsRef<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_as_ref (&self) -> ($crate::prelude::Result<&$to, $crate::errors::exports::Error>) {
				succeed! ($crate::prelude::StdAsRef::as_ref (self));
			}
		}
	);
}


macro_rules! impl_try_as_ref_for_type {
	( $to : ty, $from : ty, $self : ident, $expression : expr ) => (
		impl $crate::prelude::StdTryAsRef<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_as_ref (&$self) -> ($crate::prelude::Result<&$to, $crate::errors::exports::Error>) {
				succeed! (try! ($expression));
			}
		}
		impl $crate::prelude::StdAsRef<$to> for $from {
			#[ inline (always) ]
			fn as_ref (&self) -> (&$to) {
				return $crate::prelude::StdAsRef::try_as_ref (self) .expect ("b1ff6fb6");
			}
		}
	);
}




macro_rules! impl_from_for_enum {
	( $to : ident, $tag : ident, $from : ty ) => (
		impl_from_for_enum! ($to, $tag, $from, value, value);
	);
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from ($value : $from) -> ($to) {
				return $to::$tag ($expression.into ());
			}
		}
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				succeed! ($crate::prelude::StdFrom::from (value));
			}
		}
		impl $crate::prelude::StdTryInto<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
		impl_from_for_box! ($to, $from, $value, $expression.into ());
	);
}


macro_rules! impl_try_from_for_enum {
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from ($value : $from) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				succeed! ($to::tag (try! ($expression) .into ()));
			}
		}
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from (value : $from) -> ($to) {
				return $crate::prelude::StdTryFrom::try_from (value) .expect ("86d35665");
			}
		}
		impl $crate::prelude::StdTryInto<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
		impl_try_from_for_box! ($to, $from, $value, $expression.into ());
	);
}




macro_rules! impl_unwrappers_for_box {
	( $to : ty ) => (
		impl_unwrappers_for_box ($to, $to);
	);
	( $from : ty, $to : ty) => (
		impl $crate::prelude::StdFrom<$crate::prelude::StdBox<$from>> for $to {
			#[ inline (always) ]
			fn from (value : $crate::prelude::StdBox<$from>) -> ($to) {
				return <$to>::from (*value);
			}
		}
		impl $crate::prelude::StdTryFrom<$crate::prelude::StdBox<$from>> for $to {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from (value : $crate::prelude::StdBox<$from>) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return <$to>::try_from (*value);
			}
		}
		impl $crate::prelude::StdTryInto<$to> for $crate::prelude::StdBox<$from> {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
		/*
		impl $crate::prelude::StdAsRef<$to> for $crate::prelude::StdBox<$from> {
			#[ inline (always) ]
			fn as_ref (&self) -> (&$to) {
				return <$to>::as_ref (<$from>::as_ref (self));
			}
		}
		impl $crate::prelude::StdTryAsRef<$to> for $crate::prelude::StdBox<$from> {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_as_ref (&self) -> ($crate::prelude::Result<&$to, $crate::errors::exports::Error>) {
				return <$to>::try_as_ref (<$from>::as_ref (self));
			}
		}
		*/
	);
}


macro_rules! impl_unwrappers_for_type_wrapper {
	( $from : ty, $to : ty) => (
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from (value : $from) -> ($to) {
				return $crate::prelude::StdFrom::<$to>::from (value.0);
			}
		}
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				succeed! ($crate::prelude::StdFrom::from (value));
			}
		}
		impl $crate::prelude::StdTryInto<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
		impl $crate::prelude::StdAsRef<$to> for $from {
			#[ inline (always) ]
			fn as_ref (&self) -> (&$to) {
				return &self.0;
			}
		}
		impl $crate::prelude::StdTryAsRef<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_as_ref (&self) -> ($crate::prelude::Result<&$to, $crate::errors::exports::Error>) {
				succeed! ($crate::prelude::StdAsRef::as_ref (self));
			}
		}
		impl_unwrappers_for_box! ($from, $to);
	);
}


macro_rules! impl_unwrappers_for_enum_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				if let $from::$tag (value) = value {
					succeed! (<$to>::from (value));
				} else {
					fail! (0x64d097b5);
				}
			}
		}
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from (value : $from) -> ($to) {
				return $crate::prelude::StdTryFrom::try_from (value) .expect ("686ef2f9");
			}
		}
		impl $crate::prelude::StdTryInto<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
		/*
		impl $crate::prelude::StdTryAsRef<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_as_ref (&self) -> ($crate::prelude::Result<&$to, $crate::errors::exports::Error>) {
				if let $from::$tag (ref value) = *self {
					return <$to>::try_as_ref (value);
				} else {
					fail! (0x19768613);
				}
			}
		}
		impl $crate::prelude::StdAsRef<$to> for $from {
			#[ inline (always) ]
			fn as_ref (&self) -> (&$to) {
				return $crate::prelude::StdTryAsRef::try_as_ref (self) .expect ("8dee9989");
			}
		}
		*/
		impl_unwrappers_for_box! ($from, $to);
	);
}


macro_rules! impl_unwrappers_2_for_enum_3_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				if let $from::$tag (_, value, _) = value {
					succeed! (<$to>::from (value));
				} else {
					fail! (0x7ac7cc9c);
				}
			}
		}
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from (value : $from) -> ($to) {
				return $crate::prelude::StdTryFrom::try_from (value) .expect ("328db7d1");
			}
		}
		impl $crate::prelude::StdTryInto<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_into (self) -> ($crate::prelude::Result<$to, $crate::errors::exports::Error>) {
				return $crate::prelude::StdTryFrom::try_from (self);
			}
		}
		impl $crate::prelude::StdTryAsRef<$to> for $from {
			type Error = $crate::errors::exports::Error;
			#[ inline (always) ]
			fn try_as_ref (&self) -> ($crate::prelude::Result<&$to, $crate::errors::exports::Error>) {
				if let $from::$tag (_, ref value, _) = *self {
					return <$to>::try_as_ref (value);
				} else {
					fail! (0x1e588e5f);
				}
			}
		}
		impl $crate::prelude::StdAsRef<$to> for $from {
			#[ inline (always) ]
			fn as_ref (&self) -> (&$to) {
				return $crate::prelude::StdTryAsRef::try_as_ref (self) .expect ("7d5095ee");
			}
		}
		impl_unwrappers_for_box! ($from, $to);
	);
}




macro_rules! vec_into {
	( $( $value : expr ),* ) => (
		vec! [ $( $value, )* ] .into_iter () .map (|value| value.into ()) .collect::<$crate::prelude::StdVec<_>> ()
	);
}

macro_rules! vec_map {
	( $iterator : expr, $element : pat, $expression : expr ) => (
		$iterator.map (|$element| $expression) .collect::<$crate::prelude::StdVec<_>> ()
	);
}

macro_rules! vec_map_into {
	( $vector : expr, $element : pat, $expression : expr ) => (
		$vector.into_iter () .map (|$element| $expression) .collect::<$crate::prelude::StdVec<_>> ()
	);
}

macro_rules! try_vec_map {
	( $iterator : expr, $element : pat, $expression : expr ) => (
		try! ($iterator.map (|$element| $expression) .collect::<$crate::prelude::Result<$crate::prelude::StdVec<_>, _>> ())
	);
}

macro_rules! try_vec_map_into {
	( $vector : expr, $element : pat, $expression : expr ) => (
		try! ($vector.into_iter () .map (|$element| $expression) .collect::<$crate::prelude::Result<$crate::prelude::StdVec<_>, _>> ())
	);
}

macro_rules! vec_fold {
	( $iterator : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		$iterator.fold ($initial, |$accumulator, $element| $expression)
	);
}

macro_rules! vec_fold_into {
	( $vector : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		$vector.into_iter () .fold ($initial, |$accumulator, $element| $expression)
	);
}

macro_rules! try_vec_fold {
	( $iterator : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		// FIXME:  Try to elide the `$crate::errors::exports::Error`!
		try! ($iterator.fold::<$crate::prelude::Result<_, $crate::errors::exports::Error>, _> ($crate::prelude::Result::Ok ($initial), |accumulator, $element| {
			match accumulator {
				$crate::prelude::Result::Ok ($accumulator) =>
					$expression,
				error =>
					error,
			}
		}))
	);
}

macro_rules! try_vec_fold_into {
	( $vector : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		// FIXME:  Try to elide the `$crate::errors::exports::Error`!
		try! ($vector.into_iter () .fold::<$crate::prelude::Result<_, $crate::errors::exports::Error>, _> ($crate::prelude::Result::Ok ($initial), |accumulator, $element| {
			match accumulator {
				$crate::prelude::Result::Ok ($accumulator) =>
					$expression,
				error =>
					error,
			}
		}))
	);
}

macro_rules! vec_filter {
	( $iterator : expr, $element : pat, $expression : expr ) => (
		$iterator.filter (|$element| $expression) .collect::<$crate::prelude::StdVec<_>> ()
	);
}

macro_rules! vec_filter_into {
	( $vector : expr, $element : pat, $expression : expr ) => (
		$vector.into_iter () .filter (|$element| $expression) .collect::<$crate::prelude::StdVec<_>> ()
	);
}




macro_rules! outcome_map {
	( $outcome : ident, $expression : expr ) => (
		outcome_map! ($outcome, $outcome, $expression)
	);
	( $outcome : expr, $value : pat, $expression : expr ) => (
		match $outcome {
			Ok ($value) =>
				Ok ($expression),
			Err (error) =>
				Err (error),
		}
	);
}

macro_rules! try_outcome_map {
	( $outcome : ident, $expression : expr ) => (
		try_outcome_map! ($outcome, $outcome, $expression)
	);
	( $outcome : expr, $value : pat, $expression : expr ) => (
		match $outcome {
			Ok ($value) =>
				Ok (try! ($expression)),
			Err (error) =>
				Err (error),
		}
	);
}




macro_rules! option_map {
	( $option : ident, $expression : expr ) => (
		option_map! ($option, $option, $expression)
	);
	( $option : expr, $value : pat, $expression : expr ) => (
		match $option {
			Some ($value) =>
				Some ($expression),
			None =>
				None,
		}
	);
}

macro_rules! try_option_map {
	( $option : ident, $expression : expr ) => (
		try_option_map! ($option, $option, $expression)
	);
	( $option : expr, $value : pat, $expression : expr ) => (
		match $option {
			Some ($value) =>
				Some (try! ($expression)),
			None =>
				None,
		}
	);
}




macro_rules! try_as_ref {
	( $type : ty, $value : expr ) => (
		try! ($crate::prelude::StdTryAsRef::<$type>::try_as_ref ($value))
	);
}

macro_rules! def_value_try_as_ref {
	( $identifier : ident, $type : ty) => (
		macro_rules! $identifier {
			( $value : expr ) => (
				try_as_ref! ($type, $value)
			);
		}
	);
}


macro_rules! try_into {
	( $type : ty, $value : expr ) => (
		try! ($crate::prelude::StdTryInto::<$type>::try_into ($value))
	);
}

macro_rules! def_value_try_into {
	( $identifier : ident, $type : ty) => (
		macro_rules! $identifier {
			( $value : expr ) => (
				try_into! ($type, $value)
			);
		}
	);
}


macro_rules! value_type {
	( $type : ident ) => (
		$crate::values::exports::$type
	);
}


def_value_try_as_ref! (try_as_boolean_ref, value_type! (Boolean));
def_value_try_into! (try_into_boolean, value_type! (Boolean));

def_value_try_as_ref! (try_as_number_integer_ref, value_type! (NumberInteger));
def_value_try_into! (try_into_number_integer, value_type! (NumberInteger));

def_value_try_as_ref! (try_as_number_real_ref, value_type! (NumberReal));
def_value_try_into! (try_into_number_real, value_type! (NumberReal));

def_value_try_as_ref! (try_as_character_ref, value_type! (Character));
def_value_try_into! (try_into_character, value_type! (Character));

def_value_try_as_ref! (try_as_symbol_ref, value_type! (Symbol));
def_value_try_into! (try_into_symbol, value_type! (Symbol));

def_value_try_as_ref! (try_as_string_immutable_ref, value_type! (StringImmutable));
def_value_try_into! (try_into_string_immutable, value_type! (StringImmutable));

def_value_try_as_ref! (try_as_string_mutable_ref, value_type! (StringMutable));
def_value_try_into! (try_into_string_mutable, value_type! (StringMutable));

def_value_try_as_ref! (try_as_bytes_immutable_ref, value_type! (BytesImmutable));
def_value_try_into! (try_into_bytes_immutable, value_type! (BytesImmutable));

def_value_try_as_ref! (try_as_bytes_mutable_ref, value_type! (BytesMutable));
def_value_try_into! (try_into_bytes_mutable, value_type! (BytesMutable));

def_value_try_as_ref! (try_as_pair_ref, value_type! (PairImmutable));
def_value_try_into! (try_into_pair, value_type! (PairImmutable));

def_value_try_as_ref! (try_as_array_ref, value_type! (ArrayImmutable));
def_value_try_into! (try_into_array, value_type! (ArrayImmutable));

def_value_try_as_ref! (try_as_values_ref, value_type! (Values));
def_value_try_into! (try_into_values, value_type! (Values));

def_value_try_as_ref! (try_as_error_ref, value_type! (Error));
def_value_try_into! (try_into_error, value_type! (Error));

def_value_try_as_ref! (try_as_procedure_primitive_ref, value_type! (ProcedurePrimitive));
def_value_try_into! (try_into_procedure_primitive, value_type! (ProcedurePrimitive));

def_value_try_as_ref! (try_as_procedure_extended_ref, value_type! (ProcedureExtended));
def_value_try_into! (try_into_procedure_extended, value_type! (ProcedureExtended));

def_value_try_as_ref! (try_as_procedure_extended_ref, value_type! (ProcedureNative));
def_value_try_into! (try_into_procedure_extended, value_type! (ProcedureNative));

def_value_try_as_ref! (try_as_procedure_lambda_ref, value_type! (ProcedureLambda));
def_value_try_into! (try_into_procedure_lambda, value_type! (ProcedureLambda));

def_value_try_as_ref! (try_as_syntax_primitive_ref, value_type! (SyntaxPrimitive));
def_value_try_into! (try_into_syntax_primitive, value_type! (SyntaxPrimitive));

def_value_try_as_ref! (try_as_syntax_extended_ref, value_type! (SyntaxExtended));
def_value_try_into! (try_into_syntax_extended, value_type! (SyntaxExtended));

def_value_try_as_ref! (try_as_syntax_extended_ref, value_type! (SyntaxNative));
def_value_try_into! (try_into_syntax_extended, value_type! (SyntaxNative));

def_value_try_as_ref! (try_as_syntax_lambda_ref, value_type! (SyntaxLambda));
def_value_try_into! (try_into_syntax_lambda, value_type! (SyntaxLambda));

def_value_try_as_ref! (try_as_port_ref, value_type! (Port));
def_value_try_into! (try_into_port, value_type! (Port));

def_value_try_as_ref! (try_as_context_ref, value_type! (Context));
def_value_try_into! (try_into_context, value_type! (Context));

def_value_try_as_ref! (try_as_binding_ref, value_type! (Binding));
def_value_try_into! (try_into_binding, value_type! (Binding));




macro_rules! try_as_string_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::StringRef::try ($value))
	};
}

macro_rules! try_as_bytes_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::BytesRef::try ($value))
	};
}




#[ macro_export ]
macro_rules! def_scheme_tests {
	( $identifier : ident, $source : expr ) => (
		#[ test ]
		#[ inline (never) ]
		#[ allow (non_snake_case) ]
		fn $identifier () -> () {
			let transcript_backend = $crate::prelude::io::stdout ();
			let transcript_locked = transcript_backend.lock ();
			def_scheme_tests_block! ($identifier, $source, transcript_locked);
		}
	);
}

#[ macro_export ]
macro_rules! def_scheme_tests_block {
	( $identifier : ident, $source : expr, $transcript : expr ) => ({
		use $crate::prelude::*;
		use $crate::exports::*;
		let identifier = stringify! ($identifier);
		let source = $source;
		let verbosity = env::var ("RUST_SCHEME_TESTS_DEBUG") .unwrap_or (string::String::from ("false"));
		let verbosity = if verbosity == "true" { TestVerbosity::Debug } else { TestVerbosity::Quiet };
		let mut transcript = $transcript;
		write! (transcript, "\n\n") .expect ("5afde5da");
		let outcome = parse_and_execute_tests (identifier, source, &mut transcript, verbosity);
		write! (transcript, "\n") .expect ("216bb5ee");
		transcript.flush () .expect ("a05200ec");
		outcome.expect ("d03750c4");
	});
}

#[ macro_export ]
macro_rules! def_scheme_tests_from_file {
	( $( $identifier : ident => $source : expr, )* ) => (
		$( def_scheme_tests_from_file! ($identifier, $source); )*
	);
	( $identifier : ident, $source : expr ) => (
		def_scheme_tests! ($identifier, include_str! ($source));
	);
}




#[ macro_export ]
macro_rules! def_scheme_benchmarks {
	( $identifier : ident, $source : expr ) => (
		#[ bench ]
		#[ inline (never) ]
		#[ allow (non_snake_case) ]
		fn $identifier (bencher : &mut $crate::prelude::test::Bencher) -> () {
			let transcript_backend = $crate::prelude::io::stdout ();
			let transcript_locked = transcript_backend.lock ();
			def_scheme_benchmarks_block! ($identifier, $source, bencher, transcript_locked);
		}
	);
}

#[ macro_export ]
macro_rules! def_scheme_benchmarks_from_file {
	( $( $identifier : ident => $source : expr, )* ) => (
		$( def_scheme_benchmarks_from_file! ($identifier, $source); )*
	);
	( $identifier : ident, $source : expr ) => (
		def_scheme_benchmarks! ($identifier, include_str! ($source));
	);
}

#[ macro_export ]
macro_rules! def_scheme_benchmarks_block {
	( $identifier : ident, $source : expr, $bencher : expr, $transcript : expr ) => ({
		use $crate::prelude::*;
		use $crate::exports::*;
		let identifier = stringify! ($identifier);
		let source = $source;
		let verbosity = env::var ("RUST_SCHEME_BENCHMARKS_DEBUG") .unwrap_or (string::String::from ("false"));
		let verbosity = if verbosity == "true" { TestVerbosity::Debug } else { TestVerbosity::Quiet };
		let output = env::var ("RUST_SCHEME_BENCHMARKS_OUTPUT") .ok ();
		let output = if let Some (output) = output { Some (output.replace ("{IDENTIFIER}", identifier)) } else { None };
		let mut transcript = $transcript;
		write! (transcript, "\n\n") .expect ("42d6a453");
		let outcome = if let Some (output) = output {
			let mut buffer = StdVec::new ();
			let outcome = parse_and_benchmark_tests (identifier, source, $bencher, &mut buffer, verbosity);
			transcript.write_all (&buffer) .expect ("e987851f");
			let mut output = fs::File::create (output) .expect ("25b456ed");
			output.write_all (&buffer) .expect ("41e00f08");
			outcome
		} else {
			parse_and_benchmark_tests (identifier, source, $bencher, &mut transcript, verbosity)
		};
		write! (transcript, "\n") .expect ("276ffb09");
		transcript.flush () .expect ("39279869");
		outcome.expect ("65639c2b");
	});
}




#[ macro_export ]
macro_rules! def_test {
	( $identifier : ident, $expression : expr ) => (
		#[ test ]
		#[ inline (never) ]
		#[ allow (non_snake_case) ]
		fn $identifier () -> () {
			#[ allow (unused_imports) ]
			use $crate::prelude::*;
			#[ allow (unused_imports) ]
			use $crate::exports::*;
			$expression
		}
	);
}

