

macro_rules! succeeded {
	( $outcome : expr ) => (
		::std::result::Result::Ok ($outcome.into ())
	);
}

macro_rules! failed {
	( $code : expr ) => (
		::std::result::Result::Err ($crate::errors::error_generic ($code))
	);
}

macro_rules! failed_unimplemented {
	( $code : expr ) => (
		::std::result::Result::Err ($crate::errors::error_unimplemented ($code))
	);
}


macro_rules! succeed {
	( $outcome : expr ) => (
		return succeeded! ($outcome)
	);
}

macro_rules! fail {
	( $code : expr ) => (
		return failed! ($code)
	);
}

macro_rules! fail_unimplemented {
	( $code : expr ) => (
		return failed_unimplemented! ($code)
	);
}




#[ allow (unused_macros) ]
macro_rules! try_some {
	( $option : expr, $code : expr ) => {
		if let Some ( value ) = $option {
			value
		} else {
			fail! ($code);
		}
	};
}

#[ allow (unused_macros) ]
macro_rules! try_some_ref {
	( $option : expr, $code : expr ) => {
		if let Some ( ref value ) = $option {
			value
		} else {
			fail! ($code);
		}
	};
}

#[ allow (unused_macros) ]
macro_rules! try_some_2 {
	( $result : expr, $code : expr ) => {
		try_some! (try! ($result), $code)
	};
}




#[ allow (unused_macros) ]
macro_rules! enforce_value_class {
	( $class : ident, $value : expr, $code : expr ) => (
		if !$value.is (ValueClass::$class) {
			return failed! ($code);
		}
	);
	( $class : ident, $value : expr ) => (
		enforce_value_class ($value, 0xacc9dfc7)
	);
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_null {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Null, $value, $code) );
	( $value : expr ) => ( enforce_value_is_null! ($value, 0x85d6deef) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_void {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Void, $value, $code) );
	( $value : expr ) => ( enforce_value_is_void! ($value, 0xe2116f5f) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_undefined {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Undefined, $value, $code) );
	( $value : expr ) => ( enforce_value_is_undefined! ($value, 0x11c91a64) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_boolean {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Boolean, $value, $code) );
	( $value : expr ) => ( enforce_value_is_boolean! ($value, 0xd45dac18) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_number {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Number, $value, $code) );
	( $value : expr ) => ( enforce_value_is_number! ($value, 0x7040b2a3) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_number_integer {
	( $value : expr, $code : expr ) => ( enforce_value_class! (NumberInteger, $value, $code) );
	( $value : expr ) => ( enforce_value_is_number_integer! ($value, 0x97a15322) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_number_real {
	( $value : expr, $code : expr ) => ( enforce_value_class! (NumberReal, $value, $code) );
	( $value : expr ) => ( enforce_value_is_number_real! ($value, 0x1e7b56aa) );
}




#[ allow (unused_macros) ]
macro_rules! enforce_value_unwrap {
	( $class : ident, $value : expr, $code : expr ) => (
		match $value {
			Value::$class (ref value) => value,
			_ => return failed! ($code),
		}
	);
	( $class : ident, $value : expr ) => (
		enforce_value_unwrap ($value, 0xf5b2b46e)
	);
}

#[ allow (unused_macros) ]
macro_rules! enforce_boolean_unwrap {
	( $value : expr, $code : expr ) => ( enforce_value_unwrap! (Boolean, $value, $code) );
	( $value : expr ) => ( enforce_boolean_unwrap! ($value, 0xdce0860d) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_number_integer_unwrap {
	( $value : expr, $code : expr ) => ( enforce_value_unwrap! (NumberInteger, $value, $code) );
	( $value : expr ) => ( enforce_number_integer_unwrap! ($value, 0x57bb1805) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_number_real_unwrap {
	( $value : expr, $code : expr ) => ( enforce_value_unwrap! (NumberReal, $value, $code) );
	( $value : expr ) => ( enforce_number_real_unwrap! ($value, 0x83a1ca24) );
}




#[ allow (unused_macros) ]
macro_rules! impl_from_for_type {
	( $to : ident, $from : ty ) => (
		impl_from_for_type! ($to, $from, value, $to (value.into ()));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl StdFrom<$from> for $to {
			fn from ($value : $from) -> ($to) { <$to>::into ($expression) }
		}
	);
}

#[ allow (unused_macros) ]
macro_rules! impl_from_for_enum {
	( $to : ident, $tag : ident, $from : ty ) => (
		impl_from_for_type! ($to, $from, value, $to::$tag (value.into ()));
	);
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl_from_for_type! ($to, $from, $value, $to::$tag ($expression.into ()));
	);
}




#[ allow (unused_macros) ]
macro_rules! impl_into_for_type {
	( $to : ident, $from : ty ) => (
		impl_into_for_type! ($to, $from, value, $to (value.into ()));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl StdInto<$to> for $from {
			fn into ($value : $from) -> ($to) { <$to>::into ($expression) }
		}
	);
}

#[ allow (unused_macros) ]
macro_rules! impl_into_for_enum {
	( $to : ident, $tag : ident, $from : ty ) => (
		impl_into_for_type! ($to, $tag, $from, value, $to::$tag (value.into ()));
	);
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl_into_for_type! ($to, $tag, $from, $value, $to::$tag ($expression.into ()));
	);
}




#[ allow (unused_macros) ]
macro_rules! impl_unwrappers_for_type_wrapper {
	( $from : ty, $to : ty) => (
		impl StdFrom<$from> for $to {
			fn from (value : $from) -> ($to) {
				value.0
			}
		}
		impl<'a> StdAsRef<$to> for $from {
			fn as_ref (&self) -> (&$to) {
				&self.0
			}
		}
	);
}

#[ allow (unused_macros) ]
macro_rules! impl_unwrappers_for_enum_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl StdTryFrom<$from> for $to {
			type Error = super::errors::Error;
			fn try_from (value : $from) -> (Outcome<$to>) {
				if let $from::$tag (value) = value {
					Ok (value)
				} else {
					failed! (0x64d097b5)
				}
			}
		}
		impl StdFrom<$from> for $to {
			fn from (value : $from) -> ($to) {
				StdTryFrom::try_from (value) .expect ("686ef2f9")
			}
		}
		impl<'a> StdTryAsRef<$to> for $from {
			type Error = super::errors::Error;
			fn try_as_ref (&self) -> (Outcome<&$to>) {
				if let $from::$tag (ref value) = *self {
					Ok (value)
				} else {
					failed! (0x19768613)
				}
			}
		}
		impl<'a> StdAsRef<$to> for $from {
			fn as_ref (&self) -> (&$to) {
				StdTryAsRef::try_as_ref (self) .expect ("8dee9989")
			}
		}
	);
}




#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! vec_into {
	( $( $value : expr ),* ) => (
		vec! [ $( $value, )* ] .into_iter () .map (|value| value.into ()) .collect ()
	);
}

#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! vec_explode_1 {
	( $value : expr ) => (
		{
			let mut iterator = $value.into_iter ();
			iterator.next () .expect ("a116f5d2")
		}
	);
}

#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! vec_explode_1n {
	( $value : expr ) => (
		{
			let mut iterator = $value.into_iter ();
			(
				iterator.next () .expect ("a116f5d2"),
				iterator.collect ()
			)
		}
	);
}

#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! vec_explode_2 {
	( $value : expr ) => (
		{
			let mut iterator = $value.into_iter ();
			(
				iterator.next () .expect ("bab94a35"),
				iterator.next () .expect ("0eba5eb6"),
			)
		}
	);
}




#[ allow (unused_macros) ]
macro_rules! try_as_ref {
	( $type : ty, $value : expr ) => (
		try! ($crate::runtime::exports::StdTryAsRef::<$type>::try_as_ref ($value));
	);
}

#[ allow (unused_macros) ]
macro_rules! def_try_as_ref {
	( $identifier : ident, $type : ty) => (
		#[ allow (unused_macros) ]
		macro_rules! $identifier {
			( $value : expr ) => (
				try_as_ref! ($type, $value);
			);
		}
	);
}


#[ allow (unused_macros) ]
macro_rules! try_into {
	( $type : ty, $value : expr ) => (
		// try! ($crate::runtime::exports::StdTryInto::<$type>::try_into ($value));
		try! ($crate::runtime::exports::StdTryFrom::try_from ($value));
	);
}

#[ allow (unused_macros) ]
macro_rules! def_try_into {
	( $identifier : ident, $type : ty) => (
		#[ allow (unused_macros) ]
		macro_rules! $identifier {
			( $value : expr ) => (
				try_into! ($type, $value);
			);
		}
	);
}


def_try_as_ref! (try_as_symbol_ref, Symbol);
def_try_into! (try_into_symbol, Symbol);




#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! def_tests {
	( $identifier : ident, $source : expr ) => (
		
		#[ test ]
		fn $identifier () -> () {
			
			use $crate::exports::*;
			
			let print = env! ("RUST_SCHEME_TESTS_PRINT") == "true";
			let source = $source;
			let tests = parse_tests (source) .expect ("434d2a0c");
			
			let context = Context::new (None);
			context.define_all (language_r7rs_generate_binding_templates () .expect ("956a718b") .as_ref ()) .expect ("dedce922");
			context.define_all (language_builtins_generate_binding_templates () .expect ("242fdc5a") .as_ref ()) .expect ("2e274a94");
			
			for (input_syntax, output_syntax) in tests {
				
				if print {
					println! ();
					println! (">> {} => {} ;", input_syntax, output_syntax);
				}
				
				let input_expression = compile (&context, &input_syntax) .expect ("688d5914");
				let output_expression = compile (&context, &output_syntax) .expect ("a0c9bbd3");
				
				if print {
					println! ("## {:#?}", input_expression);
				}
				
				let input_value = evaluate (&context, &input_expression) .expect ("c824095a");
				let output_value = evaluate (&context, &output_expression) .expect ("13a4fe58");
				
				assert_eq! (input_value, output_value);
				
				if print {
					println! ();
				}
			}
		}
	);
}

#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! def_tests_from_file {
	( $( $identifier : ident => $source : expr, )* ) => (
		$( def_tests_from_file! ($identifier, $source); )*
	);
	( $identifier : ident, $source : expr ) => (
		def_tests! ($identifier, include_str! ($source));
	);
}

