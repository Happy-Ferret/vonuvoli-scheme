

#[ allow (unused_macros) ]
macro_rules! succeeded {
	( $outcome : expr ) => (
		::std::result::Result::Ok ($outcome.into ())
	);
}

#[ allow (unused_macros) ]
macro_rules! failed {
	( $code : expr ) => (
		::std::result::Result::Err ($crate::errors::error_generic ($code))
	);
}

#[ allow (unused_macros) ]
macro_rules! failed_unimplemented {
	( $code : expr ) => (
		::std::result::Result::Err ($crate::errors::error_unimplemented ($code))
	);
}


#[ allow (unused_macros) ]
macro_rules! succeed {
	( $outcome : expr ) => (
		return succeeded! ($outcome)
	);
}

#[ allow (unused_macros) ]
macro_rules! fail {
	( $code : expr ) => (
		return failed! ($code)
	);
}

#[ allow (unused_macros) ]
macro_rules! fail_unimplemented {
	( $code : expr ) => (
		return failed_unimplemented! ($code)
	);
}




#[ allow (unused_macros) ]
macro_rules! try_some {
	( $option : expr, $code : expr ) => {
		if let Some ( value ) = $option {
			value
		} else {
			fail! ($code);
		}
	};
}

#[ allow (unused_macros) ]
macro_rules! try_some_2 {
	( $result : expr, $code : expr ) => {
		try_some! (try! ($result), $code)
	};
}




#[ allow (unused_macros) ]
macro_rules! enforce_value_class {
	( $class : ident, $value : expr, $code : expr ) => (
		if !$value.is (ValueClass::$class) {
			return failed! ($code);
		}
	);
	( $class : ident, $value : expr ) => (
		enforce_value_class ($value, 0xacc9dfc7)
	);
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_null {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Null, $value, $code) );
	( $value : expr ) => ( enforce_value_is_null! ($value, 0x85d6deef) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_void {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Void, $value, $code) );
	( $value : expr ) => ( enforce_value_is_void! ($value, 0xe2116f5f) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_undefined {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Undefined, $value, $code) );
	( $value : expr ) => ( enforce_value_is_undefined! ($value, 0x11c91a64) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_boolean {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Boolean, $value, $code) );
	( $value : expr ) => ( enforce_value_is_boolean! ($value, 0xd45dac18) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_number {
	( $value : expr, $code : expr ) => ( enforce_value_class! (Number, $value, $code) );
	( $value : expr ) => ( enforce_value_is_number! ($value, 0x7040b2a3) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_number_integer {
	( $value : expr, $code : expr ) => ( enforce_value_class! (NumberInteger, $value, $code) );
	( $value : expr ) => ( enforce_value_is_number_integer! ($value, 0x97a15322) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_is_number_real {
	( $value : expr, $code : expr ) => ( enforce_value_class! (NumberReal, $value, $code) );
	( $value : expr ) => ( enforce_value_is_number_real! ($value, 0x1e7b56aa) );
}




#[ allow (unused_macros) ]
macro_rules! enforce_value_unwrap {
	( $class : ident, $value : expr, $code : expr ) => (
		match $value {
			Value::$class (ref value) => value,
			_ => return failed! ($code),
		}
	);
	( $class : ident, $value : expr ) => (
		enforce_value_unwrap ($value, 0xf5b2b46e)
	);
}

#[ allow (unused_macros) ]
macro_rules! enforce_boolean_unwrap {
	( $value : expr, $code : expr ) => ( enforce_value_unwrap! (Boolean, $value, $code) );
	( $value : expr ) => ( enforce_boolean_unwrap! ($value, 0xdce0860d) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_number_integer_unwrap {
	( $value : expr, $code : expr ) => ( enforce_value_unwrap! (NumberInteger, $value, $code) );
	( $value : expr ) => ( enforce_number_integer_unwrap! ($value, 0x57bb1805) );
}

#[ allow (unused_macros) ]
macro_rules! enforce_number_real_unwrap {
	( $value : expr, $code : expr ) => ( enforce_value_unwrap! (NumberReal, $value, $code) );
	( $value : expr ) => ( enforce_number_real_unwrap! ($value, 0x83a1ca24) );
}




#[ allow (unused_macros) ]
macro_rules! impl_from_for_type {
	( $to : ident, $from : ty ) => (
		impl_from_for_type! ($to, $from, value, $to (value.into ()));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl StdFrom<$from> for $to {
			#[ inline ( always ) ]
			fn from ($value : $from) -> ($to) { <$to>::into ($expression) }
		}
	);
}

#[ allow (unused_macros) ]
macro_rules! impl_from_for_enum {
	( $to : ident, $tag : ident, $from : ty ) => (
		impl_from_for_type! ($to, $from, value, $to::$tag (value.into ()));
	);
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl_from_for_type! ($to, $from, $value, $to::$tag ($expression.into ()));
	);
}




#[ allow (unused_macros) ]
macro_rules! impl_into_for_type {
	( $to : ident, $from : ty ) => (
		impl_into_for_type! ($to, $from, value, $to (value.into ()));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl StdInto<$to> for $from {
			#[ inline ( always ) ]
			fn into ($value : $from) -> ($to) { <$to>::into ($expression) }
		}
	);
}

#[ allow (unused_macros) ]
macro_rules! impl_into_for_enum {
	( $to : ident, $tag : ident, $from : ty ) => (
		impl_into_for_type! ($to, $tag, $from, value, $to::$tag (value.into ()));
	);
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl_into_for_type! ($to, $tag, $from, $value, $to::$tag ($expression.into ()));
	);
}




#[ allow (unused_macros) ]
macro_rules! impl_unwrappers_for_type_wrapper {
	( $from : ty, $to : ty) => (
		impl StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from (value : $from) -> ($to) {
				value.0
			}
		}
		impl<'a> StdAsRef<$to> for $from {
			#[ inline (always) ]
			fn as_ref (&self) -> (&$to) {
				&self.0
			}
		}
	);
}

#[ allow (unused_macros) ]
macro_rules! impl_unwrappers_for_enum_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl StdTryFrom<$from> for $to {
			type Error = super::errors::Error;
			#[ inline (always) ]
			fn try_from (value : $from) -> (Outcome<$to>) {
				if let $from::$tag (value) = value {
					Ok (value)
				} else {
					failed! (0x64d097b5)
				}
			}
		}
		impl StdFrom<$from> for $to {
			#[ inline (always) ]
			fn from (value : $from) -> ($to) {
				StdTryFrom::try_from (value) .unwrap ()
			}
		}
		impl<'a> StdTryAsRef<$to> for $from {
			type Error = super::errors::Error;
			#[ inline (always) ]
			fn try_as_ref (&self) -> (Outcome<&$to>) {
				if let $from::$tag (ref value) = *self {
					Ok (value)
				} else {
					failed! (0x19768613)
				}
			}
		}
		impl<'a> StdAsRef<$to> for $from {
			#[ inline (always) ]
			fn as_ref (&self) -> (&$to) {
				StdTryAsRef::try_as_ref (self) .unwrap ()
			}
		}
	);
}




#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! vec_into {
	( $( $value : expr ),* ) => (
		vec! [ $( $value, )* ] .into_iter () .map (|value| value.into ()) .collect ()
	);
}




#[ allow (unused_macros) ]
macro_rules! try_as_ref {
	( $type : ty, $value : expr ) => (
		try! ($crate::runtime::exports::StdTryAsRef::<$type>::try_as_ref ($value));
	);
}

#[ allow (unused_macros) ]
macro_rules! def_try_as_ref {
	( $identifier : ident, $type : ty) => (
		macro_rules! $identifier {
			( $value : expr ) => (
				try_as_ref! ($type, $value);
			);
		}
	);
}

def_try_as_ref! (try_as_symbol_ref, Symbol);




#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! def_tests {
	( $identifier : ident, $source : expr ) => (
		
		#[ test ]
		fn $identifier () -> () {
			
			use $crate::exports::*;
			
			let source = $source;
			let tests = parse_tests (source) .unwrap ();
			
			let context = language_r7rs_generate_context () .unwrap ();
			let evaluator = Evaluator::new ();
			
			for (input_syntax, output_syntax) in tests {
				
				eprintln! ();
				eprintln! (">> {} => {} ;", input_syntax, output_syntax);
				
				let input_expression = compile (&context, &input_syntax) .unwrap ();
				let output_expression = compile (&context, &output_syntax) .unwrap ();
				
				eprintln! ("## {:?}", input_expression);
				
				let input_value = evaluator.evaluate_top (&context, &input_expression) .unwrap ();
				let output_value = evaluator.evaluate_top (&context, &output_expression) .unwrap ();
				
				assert_eq! (input_value, output_value);
				
				eprintln! ();
			}
		}
	);
}

#[ macro_export ]
#[ allow (unused_macros) ]
macro_rules! def_tests_from_file {
	( $( $identifier : ident => $source : expr, )* ) => (
		$( def_tests_from_file! ($identifier, $source); )*
	);
	( $identifier : ident, $source : expr ) => (
		def_tests! ($identifier, include_str! ($source));
	);
}

