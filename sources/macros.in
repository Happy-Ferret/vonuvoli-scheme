

macro_rules! succeeded {
	( $outcome : expr ) => (
		::std::result::Result::Ok ($outcome)
	);
}

macro_rules! failed {
	( $code : expr ) => (
		::std::result::Result::Err (::errors::exports::error_generic ($code))
	);
}

macro_rules! failed_unimplemented {
	( $code : expr ) => (
		::std::result::Result::Err (::errors::exports::error_unimplemented ($code))
	);
}

macro_rules! failed_panic {
	( $code : expr ) => (
		::std::result::Result::Err (::errors::exports::error_panic ($code))
	);
}


macro_rules! succeed {
	( $outcome : expr ) => (
		return succeeded! ($outcome);
	);
}

macro_rules! fail {
	( $code : expr ) => (
		return failed! ($code);
	);
}

macro_rules! fail_unimplemented {
	( $code : expr ) => (
		return failed_unimplemented! ($code);
	);
}

macro_rules! fail_panic {
	( $code : expr ) => (
		return failed_panic! ($code)
	);
}


#[ allow (unused_macros) ]
macro_rules! enforce {
	( $expression : expr, $code : expr ) => (
		if !$expression {
			fail! ($code);
		}
	);
}




macro_rules! try_some {
	( $option : expr, $code : expr ) => (
		if let ::std::option::Option::Some (value) = $option {
			value
		} else {
			fail! ($code);
		}
	);
}

#[ allow (unused_macros) ]
macro_rules! try_some_ref {
	( $option : expr, $code : expr ) => (
		if let ::std::option::Option::Some (ref value) = $option {
			value
		} else {
			fail! ($code);
		}
	);
}

macro_rules! try_some_2 {
	( $result : expr, $code : expr ) => (
		try_some! (try! ($result), $code)
	);
}

#[ allow (unused_macros) ]
macro_rules! try_some_ref_2 {
	( $result : expr, $code : expr ) => (
		try_some_ref! (try! ($result), $code)
	);
}

macro_rules! try_or_fail {
	( $result : expr, $code : expr ) => (
		if let ::std::result::Result::Ok (value) = $result {
			value
		} else {
			fail! ($code);
		}
	);
}




macro_rules! impl_from_for_type {
	( $to : ident, $from : ty ) => (
		impl_from_for_type! ($to, $from, value, $to (value.into ()));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl StdFrom<$from> for $to {
			fn from ($value : $from) -> ($to) {
				return <$to>::into ($expression);
			}
		}
	);
}


macro_rules! impl_try_from_for_type {
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl StdTryFrom<$from> for $to {
			type Error = ::errors::exports::Error;
			fn try_from ($value : $from) -> (::std::result::Result<$to, ::errors::exports::Error>) {
				succeed! (<$to>::into (try! ($expression)));
			}
		}
		impl StdFrom<$from> for $to {
			fn from (value : $from) -> ($to) {
				return StdTryFrom::try_from (value) .expect ("d747d1de");
			}
		}
	);
}




macro_rules! impl_from_for_enum {
	( $to : ident, $tag : ident, $from : ty ) => (
		impl_from_for_enum! ($to, $tag, $from, value, value.into ());
	);
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl StdFrom<$from> for $to {
			fn from ($value : $from) -> ($to) {
				return $to::$tag ($expression);
			}
		}
	);
}


#[ allow (unused_macros) ]
macro_rules! impl_try_from_for_enum {
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl StdTryFrom<$from> for $to {
			type Error = ::errors::exports::Error;
			fn try_from ($value : $from) -> (::std::result::Result<$to, ::errors::exports::Error>) {
				succeed! ($to::tag (try! ($expression)));
			}
		}
		impl StdFrom<$from> for $to {
			fn from (value : $from) -> ($to) {
				return StdTryFrom::try_from (value) .expect ("86d35665");
			}
		}
	);
}




#[ allow (unused_macros) ]
macro_rules! impl_into_for_type {
	( $to : ident, $from : ty ) => (
		impl_into_for_type! ($to, $from, value, $to (value.into ()));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl StdInto<$to> for $from {
			fn into ($value : $from) -> ($to) {
				return <$to>::into ($expression);
			}
		}
	);
}

#[ allow (unused_macros) ]
macro_rules! impl_into_for_enum {
	( $to : ident, $tag : ident, $from : ty ) => (
		impl_into_for_type! ($to, $tag, $from, value, $to::$tag (value.into ()));
	);
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl_into_for_type! ($to, $tag, $from, $value, $to::$tag ($expression.into ()));
	);
}




macro_rules! impl_unwrappers_for_type_wrapper {
	( $from : ty, $to : ty) => (
		impl StdFrom<$from> for $to {
			fn from (value : $from) -> ($to) {
				return value.0;
			}
		}
		impl <'a> StdAsRef<$to> for $from {
			fn as_ref (&self) -> (&$to) {
				return &self.0;
			}
		}
	);
}


#[ allow (unused_macros) ]
macro_rules! impl_unwrappers_for_enum_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl StdTryFrom<$from> for $to {
			type Error = ::errors::exports::Error;
			fn try_from (value : $from) -> (::std::result::Result<$to, ::errors::exports::Error>) {
				if let $from::$tag (value) = value {
					succeed! (value);
				} else {
					fail! (0x64d097b5);
				}
			}
		}
		impl StdFrom<$from> for $to {
			fn from (value : $from) -> ($to) {
				return StdTryFrom::try_from (value) .expect ("686ef2f9");
			}
		}
		impl StdTryInto<$to> for $from {
			type Error = ::errors::exports::Error;
			fn try_into (self) -> (::std::result::Result<$to, ::errors::exports::Error>) {
				if let $from::$tag (value) = self {
					succeed! (value);
				} else {
					fail! (0x64d097b5);
				}
			}
		}
		/*
		impl StdInto<$to> for $from {
			fn into (self) -> ($to) {
				return StdTryInto::try_into (self) .expect ("9244d155");
			}
		}
		*/
		impl <'a> StdTryAsRef<$to> for $from {
			type Error = ::errors::exports::Error;
			fn try_as_ref (&self) -> (::std::result::Result<$to, ::errors::exports::Error>) {
				if let $from::$tag (ref value) = *self {
					Succeed! (value);
				} else {
					fail! (0x19768613);
				}
			}
		}
		impl <'a> StdAsRef<$to> for $from {
			fn as_ref (&self) -> (&$to) {
				return StdTryAsRef::try_as_ref (self) .expect ("8dee9989");
			}
		}
	);
}


macro_rules! impl_unwrappers_2_for_enum_3_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl StdTryFrom<$from> for $to {
			type Error = ::errors::exports::Error;
			fn try_from (value : $from) -> (::std::result::Result<$to, ::errors::exports::Error>) {
				if let $from::$tag (_, value, _) = value {
					succeed! (value);
				} else {
					fail! (0x7ac7cc9c);
				}
			}
		}
		impl StdFrom<$from> for $to {
			fn from (value : $from) -> ($to) {
				return StdTryFrom::try_from (value) .expect ("328db7d1");
			}
		}
		impl StdTryInto<$to> for $from {
			type Error = ::errors::exports::Error;
			fn try_into (self) -> (::std::result::Result<$to, ::errors::exports::Error>) {
				if let $from::$tag (_, value, _) = self {
					succeed! (value);
				} else {
					fail! (0x4e255f54);
				}
			}
		}
		/*
		impl StdInto<$to> for $from {
			fn into (self) -> ($to) {
				return StdTryInto::try_into (self) .expect ("bb1180d5");
			}
		}
		*/
		impl <'a> StdTryAsRef<$to> for $from {
			type Error = ::errors::exports::Error;
			fn try_as_ref (&self) -> (::std::result::Result<&$to, ::errors::exports::Error>) {
				if let $from::$tag (_, ref value, _) = *self {
					succeed! (value);
				} else {
					fail! (0x1e588e5f);
				}
			}
		}
		impl <'a> StdAsRef<$to> for $from {
			fn as_ref (&self) -> (&$to) {
				return StdTryAsRef::try_as_ref (self) .expect ("7d5095ee");
			}
		}
	);
}




#[ macro_export ]
macro_rules! vec_into {
	( $( $value : expr ),* ) => (
		vec! [ $( $value, )* ] .into_iter () .map (|value| value.into ()) .collect::<::std::vec::Vec<_>> ()
	);
}

#[ macro_export ]
macro_rules! vec_map {
	( $vector : expr, $element : pat, $expression : expr ) => (
		$vector.into_iter () .map (|$element| $expression) .collect::<::std::vec::Vec<_>> ()
	);
}

#[ macro_export ]
macro_rules! try_vec_map {
	( $vector : expr, $element : pat, $expression : expr ) => (
		try! ($vector.into_iter () .map (|$element| $expression) .collect::<::std::result::Result<::std::vec::Vec<_>, _>> ())
	);
}

#[ macro_export ]
macro_rules! vec_fold {
	( $vector : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		$vector.into_iter () .fold ($initial, |$accumulator, $element| $expression)
	);
}

#[ macro_export ]
macro_rules! try_vec_fold {
	( $vector : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		// FIXME:  Try to elide the `::errors::exports::Error`!
		try! ($vector.into_iter () .fold::<::std::result::Result<_, ::errors::exports::Error>, _> (::std::result::Result::Ok ($initial), |accumulator, $element| {
			match accumulator {
				::std::result::Result::Ok ($accumulator) =>
					$expression,
				error =>
					error,
			}
		}))
	);
}




#[ macro_export ]
macro_rules! option_map {
	( $option : ident, $expression : expr ) => (
		option_map! ($option, $option, $expression)
	);
	( $option : expr, $value : pat, $expression : expr ) => (
		match $option {
			Some ($value) =>
				Some ($expression),
			None =>
				None
		}
	);
}

#[ macro_export ]
macro_rules! try_option_map {
	( $option : ident, $expression : expr ) => (
		try_option_map! ($option, $option, $expression)
	);
	( $option : expr, $value : pat, $expression : expr ) => (
		match $option {
			Some ($value) =>
				Some (try! ($expression)),
			None =>
				None
		}
	);
}




macro_rules! try_as_ref {
	( $type : ty, $value : expr ) => (
		try! (::runtime::exports::StdTryAsRef::<$type>::try_as_ref ($value))
	);
}

macro_rules! def_try_as_ref {
	( $identifier : ident, $type : ty) => (
		#[ allow (unused_macros) ]
		macro_rules! $identifier {
			( $value : expr ) => (
				try_as_ref! ($type, $value)
			);
		}
	);
}


macro_rules! try_into {
	( $type : ty, $value : expr ) => (
		try! (::runtime::exports::StdTryInto::<$type>::try_into ($value))
	);
}

macro_rules! def_try_into {
	( $identifier : ident, $type : ty) => (
		#[ allow (unused_macros) ]
		macro_rules! $identifier {
			( $value : expr ) => (
				try_into! ($type, $value)
			);
		}
	);
}


def_try_as_ref! (try_as_boolean_ref, ::values::exports::Boolean);
def_try_into! (try_into_boolean, ::values::exports::Boolean);

def_try_as_ref! (try_as_number_integer_ref, ::values::exports::NumberInteger);
def_try_into! (try_into_number_integer, ::values::exports::NumberInteger);

def_try_as_ref! (try_as_number_real_ref, ::values::exports::NumberReal);
def_try_into! (try_into_number_real, ::values::exports::NumberReal);

def_try_as_ref! (try_as_character_ref, ::values::exports::Character);
def_try_into! (try_into_character, ::values::exports::Character);

def_try_as_ref! (try_as_symbol_ref, ::values::exports::Symbol);
def_try_into! (try_into_symbol, ::values::exports::Symbol);

def_try_as_ref! (try_as_string_ref, ::values::exports::String);
def_try_into! (try_into_string, ::values::exports::String);

def_try_as_ref! (try_as_bytes_ref, ::values::exports::Bytes);
def_try_into! (try_into_bytes, ::values::exports::Bytes);

def_try_as_ref! (try_as_pair_ref, ::values::exports::Pair);
def_try_into! (try_into_pair, ::values::exports::Pair);

def_try_as_ref! (try_as_array_ref, ::values::exports::Array);
def_try_into! (try_into_array, ::values::exports::Array);

def_try_as_ref! (try_as_values_ref, ::values::exports::Values);
def_try_into! (try_into_values, ::values::exports::Values);

def_try_as_ref! (try_as_error_ref, ::values::exports::Error);
def_try_into! (try_into_error, ::values::exports::Error);

def_try_as_ref! (try_as_lambda_ref, ::procedures::exports::Lambda);
def_try_into! (try_into_lambda, ::procedures::exports::Lambda);

def_try_as_ref! (try_as_procedure_primitive_ref, ::primitives::exports::ProcedurePrimitive);
def_try_into! (try_into_procedure_primitive, ::primitives::exports::ProcedurePrimitive);

def_try_as_ref! (try_as_syntax_primitive_ref, ::primitives::exports::SyntaxPrimitive);
def_try_into! (try_into_syntax_primitive, ::primitives::exports::SyntaxPrimitive);

def_try_as_ref! (try_as_context_ref, ::values::exports::Context);
def_try_into! (try_into_context, ::values::exports::Context);

def_try_as_ref! (try_as_binding_ref, ::values::exports::Binding);
def_try_into! (try_into_binding, ::values::exports::Binding);




#[ macro_export ]
macro_rules! def_tests {
	( $identifier : ident, $source : expr ) => (
		#[ test ]
		fn $identifier () -> () {
			use $crate::exports::*;
			let source = $source;
			let mut transcript = std::io::stdout ();
			let verbosity = if env! ("RUST_SCHEME_TESTS_DEBUG") == "true" { TestVerbosity::Debug } else { TestVerbosity::Quiet };
			parse_and_execute_tests (source, &mut transcript, verbosity) .expect ("d03750c4");
		}
	);
}

#[ macro_export ]
macro_rules! def_tests_from_file {
	( $( $identifier : ident => $source : expr, )* ) => (
		$( def_tests_from_file! ($identifier, $source); )*
	);
	( $identifier : ident, $source : expr ) => (
		def_tests! ($identifier, include_str! ($source));
	);
}

